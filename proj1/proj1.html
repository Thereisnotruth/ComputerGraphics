<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title>Project #1 - Luxo Lamp</title>
        <style>
        html, body {
            margin: 0;
            height: 100%;
        }
        #webgl {
            width: 100%;
            height: 100%;
            display: block;
        }
        </style>
    </head>
    <body>
        <canvas id="webgl"></canvas>
    </body>
<script type="module">
import * as THREE from '../resources/three.js/build/three.module.js';
import {OrbitControls} from '../resources/three.js/examples/jsm/controls/OrbitControls.js';
import {GUI} from '../3rdparty/dat.gui.module.js';

function main() {
    const canvas = document.querySelector('#webgl');
    const renderer = new THREE.WebGLRenderer({canvas});
    renderer.shadowMap.enabled = true;
   
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('black');

    // room
    const room = {width:30, height:20};
    {
        const cubeGeo = new THREE.BoxBufferGeometry(room.width, room.height, room.width);
        const cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
        cubeMat.side = THREE.BackSide;
        const mesh = new THREE.Mesh(cubeGeo, cubeMat);
        mesh.position.set(0, room.height / 2, 0);
        mesh.receiveShadow = true;
        scene.add(mesh);
    }

    // define the luxo lamp

    // base
    const base = new THREE.Object3D();
    {
        scene.add(base);
    }
    
    // baseMesh 
    const baseMesh = {width:4, height:1, color:'red'};
    {
        baseMesh.mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1),
                                    new THREE.MeshPhongMaterial({color: baseMesh.color}));
        base.add(baseMesh.mesh);
    }
    
    // baseDisc
    const baseDisc = new THREE.Object3D();
    {
        baseDisc.angle = 20;
        base.add(baseDisc);
    }
    
    // baseDiscMesh
    const baseDiscMesh = {radius: 1, height: 0.2, color:'orange', segs:8};
    {
        baseDiscMesh.mesh = new THREE.Mesh( 
                                new THREE.CylinderBufferGeometry(baseDiscMesh.radius, 
                                    baseDiscMesh.radius, baseDiscMesh.height, baseDiscMesh.segs),
                                new THREE.MeshPhongMaterial({color: baseDiscMesh.color}));
        baseDisc.add(baseDiscMesh.mesh);
    }

    // baseJoint
    const baseJoint = new THREE.Object3D();
    {
        baseJoint.angle = -30;
        baseDisc.add(baseJoint);
    }
    
    // baseJointMesh
    const baseJointMesh = {radius: 0.5, height: 1, color: 'green', segs: 8};
    {
        baseJointMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(baseJointMesh.radius,
                                    baseJointMesh.radius, baseJointMesh.height, baseJointMesh.segs),
                                new THREE.MeshPhongMaterial({color: baseJointMesh.color}));
        baseJoint.add(baseJointMesh.mesh);
    }

    // lowerArm
    const lowerArm = new THREE.Object3D();
    {
        baseJoint.add(lowerArm);
    }

    // lowerArmMesh
    const lowerArmMesh = {radius: 0.3, height: 6, color: 'blue', segs: 32};
    {
        lowerArmMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(lowerArmMesh.radius,
                                    lowerArmMesh.radius, 1, lowerArmMesh.segs),
                                new THREE.MeshPhongMaterial({color: lowerArmMesh.color}));
        lowerArm.add(lowerArmMesh.mesh);
    }

    // middleJoint
    const middleJoint = new THREE.Object3D();
    {
        middleJoint.angle = 60;
        lowerArm.add(middleJoint);
    }

    // middleJointMesh
    const middleJointMesh = {radius: 0.5, height: 1, color: 'green', segs: 8};
    {
        middleJointMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(middleJointMesh.radius,
                                    middleJointMesh.radius, middleJointMesh.height, middleJointMesh.segs),
                                new THREE.MeshPhongMaterial({color: middleJointMesh.color}));
        middleJoint.add(middleJointMesh.mesh);
    }

    // upperArm
    const upperArm = new THREE.Object3D();
    {
        middleJoint.add(upperArm);
    }

    // upperArmMesh
    const upperArmMesh = {radius: 0.3, height: 5, color: 'blue', segs: 32};
    {
        upperArmMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(upperArmMesh.radius,
                                    upperArmMesh.radius, 1, upperArmMesh.segs),
                                new THREE.MeshPhongMaterial({color: upperArmMesh.color}));
        upperArm.add(upperArmMesh.mesh);
    }

    // headJoint
    const headJoint = new THREE.Object3D();
    {
        headJoint.angle = 30;
        upperArm.add(headJoint);
    }

    // headJointMesh
    const headJointMesh = {radius: 0.5, height: 1, color: 'green', segs: 8};
    {
        headJointMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(headJointMesh.radius,
                                    headJointMesh.radius, headJointMesh.height, headJointMesh.segs),
                                new THREE.MeshPhongMaterial({color: headJointMesh.color}));
        headJoint.add(headJointMesh.mesh);
    }

    // head
    const head = new THREE.Object3D();
    {
        headJoint.add(head);
    }
    
    // headMesh
    const headMesh = {radius1: 2.5, radius2: 1, height: 2.5, color: 'gray', segs: 32};
    {
        headMesh.mesh = new THREE.Mesh(
                            new THREE.CylinderBufferGeometry(headMesh.radius1,
                                headMesh.radius2, headMesh.height, headMesh.segs),
                            new THREE.MeshPhongMaterial({color: headMesh.color}));
        head.add(headMesh.mesh);
    }

    // lightBulb
    const lightBulb = new THREE.Object3D();
    {
        head.add(lightBulb);
    }

    // lightBulbMesh
    const lightBulbMesh = {radius: 1, color: 'white', widthSegs: 32, heightSegs: 32};
    {
        lightBulbMesh.mesh = new THREE.Mesh(
                            new THREE.SphereBufferGeometry(lightBulbMesh.radius,
                                lightBulbMesh.widthSegs, lightBulbMesh.heightSegs),
                            new THREE.MeshPhongMaterial({color: lightBulbMesh.color}));
        lightBulb.add(lightBulbMesh.mesh);
    }

    // spotLight
    const spotLight = {color: 'white', intensity: 1};
    {
        spotLight.light = new THREE.SpotLight(spotLight.color, spotLight.intensity);
        spotLight.light.castShadow = true;
        spotLight.light.target = lightBulb;
        spotLight.light.angle = THREE.MathUtils.degToRad(30);
        spotLight.helper = new THREE.SpotLightHelper(spotLight.light);
        spotLight.toggleHelper = false;
        lightBulb.add(spotLight.light);
    }

    // DegRadHelper
    class DegRadHelper {
        constructor(obj, prop) {
            this.obj = obj;
            this.prop = prop;
        }
        get value() {
            return THREE.MathUtils.radToDeg(this.obj[this.prop]);
        }
        set value(v) {
            this.obj[this.prop] = THREE.MathUtils.degToRad(v);
        }
    }

    // lightHelper;
    function lightHelper() {
        if (spotLight.toggleHelper) {
            scene.add(spotLight.helper);
        } else {
            scene.remove(spotLight.helper);
        }
    }

    // 3D Models

    // Baymax
    const Baymax = new THREE.Object3D();
    {
        scene.add(Baymax)
    }

    // BaymaxHead
    const BaymaxHead = new THREE.Object3D();
    {
        Baymax.add(BaymaxHead);
    }
    
    // BaymaxHeadMesh
    const BaymaxHeadMesh = {radius: 1, color: 'white', segs: 32};
    {
        BaymaxHeadMesh.mesh = new THREE.Mesh(
                                new THREE.SphereBufferGeometry(
                                    BaymaxHeadMesh.radius,
                                    BaymaxHeadMesh.segs,
                                    BaymaxHeadMesh.segs
                                ),
                                new THREE.MeshPhongMaterial({color: BaymaxHeadMesh.color}));
        BaymaxHeadMesh.mesh.receiveShadow = true;
        BaymaxHeadMesh.mesh.castShadow = true;
        BaymaxHead.add(BaymaxHeadMesh.mesh);
    }

    // BaymaxFace
    const BaymaxFace = new THREE.Object3D();
    {
        BaymaxHead.add(BaymaxFace);
    }

    // BaymaxEye
    const BaymaxEyeMesh = {radius: 0.2, height: 0.1, color: 'black', segs: 50};
    {
        BaymaxEyeMesh.meshL = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(
                                    BaymaxEyeMesh.radius, BaymaxEyeMesh.radius,
                                    BaymaxEyeMesh.height, BaymaxEyeMesh.segs),
                                new THREE.MeshPhongMaterial({color: BaymaxEyeMesh.color}));
        BaymaxEyeMesh.meshR = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(
                                    BaymaxEyeMesh.radius, BaymaxEyeMesh.radius,
                                    BaymaxEyeMesh.height, BaymaxEyeMesh.segs),
                                new THREE.MeshPhongMaterial({color: BaymaxEyeMesh.color}));
        BaymaxFace.add(BaymaxEyeMesh.meshL);
        BaymaxFace.add(BaymaxEyeMesh.meshR);
    }

    // BaymaxMouth
    const BaymaxMouthMesh = {width: 1.4, height: 0.1, depth: 0.1, color: 'black'};
    {
        BaymaxMouthMesh.mesh = new THREE.Mesh(
                                new THREE.BoxBufferGeometry(
                                        BaymaxMouthMesh.width,
                                        BaymaxMouthMesh.height,
                                        BaymaxMouthMesh.depth
                                ),
                                new THREE.MeshPhongMaterial({color: BaymaxMouthMesh.color}));
        BaymaxFace.add(BaymaxMouthMesh.mesh);
    }

    // BaymaxBody
    const BaymaxBody = new THREE.Object3D();
    {
        Baymax.add(BaymaxBody);
    }

    const BaymaxBodyMesh = {radius: 5, color: 'white', segs: 32};
    {
        let points = [];
        for (let deg = 0; deg <= 180; deg += 6 ) {

            let rad = Math.PI * deg / 180;
            let point = new THREE.Vector2( ( 0.72 + 0.08 * Math.cos( rad ) ) * Math.sin( rad ), - Math.cos( rad ) ); // the "egg equation"
            //console.log( point ); // x-coord should be greater than zero to avoid degenerate triangles; it is not in this formula.
            
            point.x *= 5.5;
            point.y *= 5;
            points.push( point );

        }
        BaymaxBodyMesh.mesh = new THREE.Mesh(
                            new THREE.LatheBufferGeometry(
                                points,
                                BaymaxBodyMesh.segs
                            ),
                            new THREE.MeshPhongMaterial(
                                {
                                    color: BaymaxBodyMesh.color
                                }
                            )
        );
        BaymaxBodyMesh.mesh.receiveShadow = true;
        BaymaxBodyMesh.mesh.castShadow = true;
        BaymaxBody.add(BaymaxBodyMesh.mesh);
    }

    // BaymaxChest
    const BaymaxChestMesh = {radius: 0.4, height: 0.1, color: 'white', segs: 50};
    {
        BaymaxChestMesh.mesh = new THREE.Mesh(
                                new THREE.CylinderBufferGeometry(
                                    BaymaxChestMesh.radius, BaymaxChestMesh.radius,
                                    BaymaxChestMesh.height, BaymaxChestMesh.segs),
                                new THREE.MeshPhongMaterial({color: BaymaxChestMesh.color}));
        BaymaxBody.add(BaymaxChestMesh.mesh);
    }

    // BaymaxLegs
    const BaymaxLegs = new THREE.Object3D();
    {
        BaymaxBody.add(BaymaxLegs);
    }

    // BaymaxLegsMesh
    const BaymaxLegsMesh = {color: 'white', segs: 32};
    {
        let points = [];
        for (let deg = 0; deg <= 180; deg += 6 ) {

            let rad = Math.PI * deg / 180;
            let point = new THREE.Vector2( ( 0.72 + 0.08 * Math.cos( rad ) ) * Math.sin( rad ), - Math.cos( rad ) ); // the "egg equation"
            point.x *= 2;
            point.y *= 2;
            points.push( point );

        }
        BaymaxLegsMesh.meshL = new THREE.Mesh(
                            new THREE.LatheBufferGeometry(
                                points,
                                BaymaxLegsMesh.segs
                            ),
                            new THREE.MeshPhongMaterial(
                                {
                                    color: BaymaxLegsMesh.color
                                }
                            )
        );
        BaymaxLegsMesh.meshL.receiveShadow = true;
        BaymaxLegsMesh.meshL.castShadow = true;
        BaymaxLegsMesh.meshR = new THREE.Mesh(
                            new THREE.LatheBufferGeometry(
                                points,
                                BaymaxLegsMesh.segs
                            ),
                            new THREE.MeshPhongMaterial(
                                {
                                    color: BaymaxLegsMesh.color
                                }
                            )
        );
        BaymaxLegsMesh.meshR.receiveShadow = true;
        BaymaxLegsMesh.meshR.castShadow = true;
        BaymaxLegs.add(BaymaxLegsMesh.meshL);
        BaymaxLegs.add(BaymaxLegsMesh.meshR);
    }

    // BaymaxArms
    const BaymaxArms = new THREE.Object3D();
    {
        BaymaxBody.add(BaymaxArms);
    }

    // BaymaxArmsMesh
    const BaymaxArmsMesh = {color: 'white', segs: 32};
    {
        let points = [];
        for (let deg = 0; deg <= 180; deg += 6 ) {

            let rad = Math.PI * deg / 180;
            let point = new THREE.Vector2( ( 0.72 + 0.08 * Math.cos( rad ) ) * Math.sin( rad ), - Math.cos( rad ) ); // the "egg equation"
            point.x *= 2.5;
            point.y *= 4;
            points.push( point );

        }
        BaymaxArmsMesh.meshL = new THREE.Mesh(
                            new THREE.LatheBufferGeometry(
                                points,
                                BaymaxBodyMesh.segs
                            ),
                            new THREE.MeshPhongMaterial(
                                {
                                    color: BaymaxArmsMesh.color
                                }
                            )
        );
        BaymaxArmsMesh.meshL.receiveShadow = true;
        BaymaxArmsMesh.meshL.castShadow = true;
        BaymaxArmsMesh.meshR = new THREE.Mesh(
            new THREE.LatheBufferGeometry(
                points,
                BaymaxArmsMesh.segs
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: BaymaxArmsMesh.color
                }
            )
        );
        BaymaxArmsMesh.meshR.receiveShadow = true;
        BaymaxArmsMesh.meshR.castShadow = true;
        BaymaxArms.add(BaymaxArmsMesh.meshL);
        BaymaxArms.add(BaymaxArmsMesh.meshR);
    }

    // torusKnot
    const torusKnot = new THREE.Object3D();
    {
        scene.add(torusKnot);
    }

    // torusKnotMesh
    const torusKnotMesh = {radius: 2.5, tubeRadius: 1.5, raSegs: 30, tubSegs: 100, p: 2, q: 3, color: 'red'};
    {
        torusKnotMesh.mesh = new THREE.Mesh(
            new THREE.TorusKnotBufferGeometry(
                torusKnotMesh.radius,
                torusKnotMesh.tubeRadius,
                torusKnotMesh.raSegs,
                torusKnotMesh.tubSegs,
                torusKnotMesh.p,
                torusKnotMesh.q
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: torusKnotMesh.color
                }
            )
        );
        torusKnotMesh.mesh.receiveShadow = true;
        torusKnotMesh.mesh.castShadow = true;
        torusKnot.add(torusKnotMesh.mesh);
    }

    // heart
    const heart = new THREE.Object3D();
    {
        scene.add(heart);
    }

    // heartMesh
    const heartMesh = {color: 'pink'};
    {
        const shape = new THREE.Shape();
        const x = -2.5;
        const y = -5;
        shape.moveTo(x + 2.5, y + 2.5);
        shape.bezierCurveTo(x + 2.5, y + 2.5, x + 2, y, x, y);
        shape.bezierCurveTo(x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5);
        shape.bezierCurveTo(x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5);
        shape.bezierCurveTo(x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5);
        shape.bezierCurveTo(x + 8, y + 3.5, x + 8, y, x + 5, y);
        shape.bezierCurveTo(x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5);

        const extrudeSettings = {
            steps: 2,  
            depth: 2,  
            bevelEnabled: true,  
            bevelThickness: 1,  
            bevelSize: 1,  
            bevelSegments: 2,  
        };
        heartMesh.mesh = new THREE.Mesh(
            new THREE.ExtrudeBufferGeometry(shape, extrudeSettings),
            new THREE.MeshPhongMaterial(
                {
                    color: heartMesh.color
                }
            )
        );
        heartMesh.mesh.receiveShadow = true;
        heartMesh.mesh.castShadow = true;
        heart.add(heartMesh.mesh);
    }

    // car
    const car = new THREE.Object3D();
    {
        scene.add(car);
    }

    // carMesh
    const carMesh = {frameWidth: 11, frameHeight: 2, frameDepth: 6, frameColor: 'blue', wheelColor: 'black'};
    {
        const shape = new THREE.Shape();
        shape.moveTo(1, 1);
        shape.bezierCurveTo(0, 0, 0.3, 0.3, 0, 0);

        const extrudeSettings = {
            steps: 1,  
            depth: 4,  
            bevelEnabled: true,  
            bevelThickness: 1,  
            bevelSize: 2,  
            bevelSegments: 32,
        };
        
        // upperFrame
        carMesh.mesh1 = new THREE.Mesh(
            new THREE.ExtrudeGeometry(shape, extrudeSettings),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.frameColor
                }
            )
        );
        carMesh.mesh1.rotation.z = THREE.MathUtils.degToRad(-45);
        carMesh.mesh1.position.set(0, 1, -2);
        carMesh.mesh1.receiveShadow = true;
        carMesh.mesh1.castShadow = true;
        
        // lowerFrame
        carMesh.mesh2 = new THREE.Mesh(
            new THREE.BoxBufferGeometry(
                carMesh.frameWidth, carMesh.frameHeight, carMesh.frameDepth
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.frameColor
                }
            )
        );
        carMesh.mesh2.receiveShadow = true;
        carMesh.mesh2.castShadow = true;
        
        // wheel1
        carMesh.mesh3 = new THREE.Mesh(
            new THREE.CylinderBufferGeometry(
                1, 1, 1, 50
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.wheelColor
                }
            )
        )
        carMesh.mesh3.rotation.x = THREE.MathUtils.degToRad(90);
        carMesh.mesh3.position.set(3, -1, 2.51);
        carMesh.mesh3.receiveShadow = true;
        carMesh.mesh3.castShadow = true;

        // wheel2
        carMesh.mesh4 = new THREE.Mesh(
            new THREE.CylinderBufferGeometry(
                1, 1, 1, 50
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.wheelColor
                }
            )
        )
        carMesh.mesh4.rotation.x = THREE.MathUtils.degToRad(90);
        carMesh.mesh4.position.set(3, -1, -2.51);
        carMesh.mesh4.receiveShadow = true;
        carMesh.mesh4.castShadow = true;

        // wheel3
        carMesh.mesh5 = new THREE.Mesh(
            new THREE.CylinderBufferGeometry(
                1, 1, 1, 50
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.wheelColor
                }
            )
        )
        carMesh.mesh5.rotation.x = THREE.MathUtils.degToRad(90);
        carMesh.mesh5.position.set(-3, -1, -2.51);
        carMesh.mesh5.receiveShadow = true;
        carMesh.mesh5.castShadow = true;

        // wheel4
        carMesh.mesh6 = new THREE.Mesh(
            new THREE.CylinderBufferGeometry(
                1, 1, 1, 50
            ),
            new THREE.MeshPhongMaterial(
                {
                    color: carMesh.wheelColor
                }
            )
        )
        carMesh.mesh6.rotation.x = THREE.MathUtils.degToRad(90);
        carMesh.mesh6.position.set(-3, -1, 2.51);
        carMesh.mesh6.receiveShadow = true;
        carMesh.mesh6.castShadow = true;

        car.add(carMesh.mesh1);
        car.add(carMesh.mesh2);
        car.add(carMesh.mesh3);
        car.add(carMesh.mesh4);
        car.add(carMesh.mesh5);
        car.add(carMesh.mesh6);
    }


    function updateLuxo() {
        base.position.y = baseMesh.height/2;
        baseMesh.mesh.scale.set(baseMesh.width, baseMesh.height, baseMesh.width);

        baseDisc.position.y = baseMesh.height/2 + baseDiscMesh.height/2;
        baseDisc.rotation.y = THREE.MathUtils.degToRad(baseDisc.angle);

        baseJoint.rotation.z = THREE.MathUtils.degToRad(90);
        baseJoint.rotation.x = THREE.MathUtils.degToRad(baseJoint.angle - 90);
        baseJoint.position.y = baseDiscMesh.height/2;

        lowerArm.rotation.x = THREE.MathUtils.degToRad(90);
        lowerArmMesh.mesh.scale.set(1, lowerArmMesh.height, 1);
        lowerArmMesh.mesh.position.y = lowerArmMesh.height/2;

        middleJoint.position.y = lowerArmMesh.height;
        middleJoint.rotation.x = THREE.MathUtils.degToRad(90);
        middleJoint.rotation.y = THREE.MathUtils.degToRad(middleJoint.angle);

        upperArm.rotation.x = THREE.MathUtils.degToRad(-90);
        upperArmMesh.mesh.scale.set(1, upperArmMesh.height, 1);
        upperArmMesh.mesh.position.y = upperArmMesh.height/2;

        headJoint.position.y = upperArmMesh.height;
        headJoint.rotation.x = THREE.MathUtils.degToRad(90);
        headJoint.rotation.y = THREE.MathUtils.degToRad(headJoint.angle);

        head.rotation.x = THREE.MathUtils.degToRad(90);
        head.rotation.z = THREE.MathUtils.degToRad(90);
        headMesh.mesh.position.y = headMesh.height/2;

        lightBulb.position.y = headMesh.height + lightBulbMesh.radius;
        lightBulbMesh.mesh.position.y = lightBulbMesh.radius;
        lightBulb.rotation.z = THREE.MathUtils.degToRad(180);

        if (spotLight.toggleHelper) {
            spotLight.helper.update();
        }

        Baymax.position.y = 7;
        Baymax.position.x = 10;
        Baymax.position.z = -10;
        Baymax.rotation.y = THREE.MathUtils.degToRad(90);

        BaymaxHead.position.y = BaymaxBodyMesh.radius + 0.8;
        BaymaxHeadMesh.mesh.scale.set(1, 1, 1.5);

        BaymaxFace.position.x = -0.95;
        BaymaxFace.rotation.z = THREE.MathUtils.degToRad(90);

        BaymaxEyeMesh.meshL.position.z = -0.7;
        BaymaxEyeMesh.meshR.position.z = 0.7;
        BaymaxEyeMesh.meshR.rotation.x = THREE.MathUtils.degToRad(20);
        BaymaxEyeMesh.meshL.rotation.x = THREE.MathUtils.degToRad(-20);
        
        BaymaxMouthMesh.mesh.rotation.x = THREE.MathUtils.degToRad(90);
        BaymaxMouthMesh.mesh.rotation.z = THREE.MathUtils.degToRad(90);

        BaymaxChestMesh.mesh.position.x = -1.8;
        BaymaxChestMesh.mesh.rotation.z = THREE.MathUtils.degToRad(40);
        BaymaxChestMesh.mesh.rotation.x = THREE.MathUtils.degToRad(35);
        BaymaxChestMesh.mesh.position.y = 3.8;
        BaymaxChestMesh.mesh.position.z = 1.5;

        BaymaxLegs.position.y = -(BaymaxBodyMesh.radius + 0.6);
        BaymaxLegsMesh.meshL.rotation.x = THREE.MathUtils.degToRad(-20);
        BaymaxLegsMesh.meshL.rotation.z = THREE.MathUtils.degToRad(180);
        BaymaxLegsMesh.meshR.rotation.x = THREE.MathUtils.degToRad(20);
        BaymaxLegsMesh.meshR.rotation.z = THREE.MathUtils.degToRad(180);
        BaymaxLegsMesh.meshL.position.z = -1.3;
        BaymaxLegsMesh.meshR.position.z = 1.3;

        BaymaxArmsMesh.meshL.position.z = -3;
        BaymaxArmsMesh.meshR.position.z = 3;
        BaymaxArmsMesh.meshL.rotation.x = THREE.MathUtils.degToRad(20);
        BaymaxArmsMesh.meshR.rotation.x = THREE.MathUtils.degToRad(-20);

        torusKnot.position.y = 6;
        torusKnot.position.x = -10;
        torusKnot.position.z = -10;

        heart.position.set(-8, 4, 10);
        heart.rotation.z = THREE.MathUtils.degToRad(180);
        heart.rotation.y = THREE.MathUtils.degToRad(150);
        heartMesh.mesh.scale.set(0.5, 0.5, 0.5);

        car.position.set(7, 2, 10);
    }

    updateLuxo();

    {
        const gui = new GUI();
        let folder;
        folder = gui.addFolder('base (red box)');
        folder.add(base.position, 'x', -room.width/2, room.width/2, 1).name('x').onChange(updateLuxo);
        folder.add(base.position, 'z', -room.width/2, room.width/2, 1).name('z').onChange(updateLuxo);
        folder.add(baseMesh, 'height', 0.1, 2, 0.1).name('height').onChange(updateLuxo);
        folder.open();

        gui.add(baseDisc, 'angle', 0, 360, 1).name('angle (yellow)').onChange(updateLuxo);

        folder = gui.addFolder('arm (blue) lengths');
        folder.add(lowerArmMesh, 'height', 2, 7, 0.1).name('lower').onChange(updateLuxo);
        folder.add(upperArmMesh, 'height', 2, 7, 0.1).name('upper').onChange(updateLuxo);
        folder.open();

        folder = gui.addFolder('joint (green) angles');
        folder.add(baseJoint, 'angle', -180, 180, 1).name('base').onChange(updateLuxo);
        folder.add(middleJoint, 'angle', -180, 180, 1).name('middle').onChange(updateLuxo);
        folder.add(headJoint, 'angle', -180, 180, 1).name('head').onChange(updateLuxo);
        folder.open();

        folder = gui.addFolder('light bulb');
        folder.add(new DegRadHelper(spotLight.light, 'angle'), 'value', 10, 90, 1).name('angle').onChange(updateLuxo);
        folder.add(spotLight, 'toggleHelper').name('show helper').onChange(lightHelper);
        folder.open();

    }


    {   // point light
        const color = 0xFFFFFF;
        const intensity = 0.5;
        const light = new THREE.PointLight(color, intensity);
        light.position.set(0, room.height, 0);
        light.castShadow = true;
        scene.add(light);
        
        const helper = new THREE.PointLightHelper(light);
        scene.add(helper);
    }
    {   // an ambient light
        const light = new THREE.AmbientLight('white', 0.3);
        scene.add(light);
    }


    const fov = 45;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(0, room.height*0.5, room.width*1.4);
    
    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, room.height*0.5, 0);
    controls.update();
 
    function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
    }
    
    function render() {
    
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }
        
        renderer.render(scene, camera);
        
        requestAnimationFrame(render);
    }
    
    requestAnimationFrame(render);
}

main();
</script>
</html>

